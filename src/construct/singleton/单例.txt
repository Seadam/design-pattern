##破坏单例
1 反射破坏单例
通过setAccessible(true),然后newInstance()强制访问私有构造方法,创建多个对象
解决方法:
可以在构造方法加判断,单例实例不为空时不允许创建对象,抛出异常.

2 序列化破坏单例
一个单例对象创建好之后,有时候需要将对象序列化后存入磁盘,下次使用时再从磁盘读取并反序列化,将其转化为内存对象.
反序列化后的对象会重新分配内存,即重新创建,破坏了单例原则.
解决方法:
在单例类中增加readResolve()方法,jdk会在反序列化时返回该方法返回的对象,而不用重新生成.
private Object readResolve(){
    return INSTANCE;
}

实现单例的其他方式:
注册式单例模式:
1 枚举式单例
2 容器式单例

ThreadLocal线程单例实现方式